開始日 2023/05/08  
読了日 2023/ * / *  
著者 米田優峻 2022年9月16日初版

# 目次
- [序章 競技プログラミング入門](https://github.com/humiki-kirora/enginner_study/blob/main/%E8%AA%AD%E6%9B%B8/%E7%AB%B6%E6%8A%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E9%89%84%E5%89%87/%E7%AB%B6%E6%8A%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E9%89%84%E5%89%87.md#%E5%BA%8F%E7%AB%A0-%E7%AB%B6%E6%8A%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E5%85%A5%E9%96%80)
- [1章 アルゴリズムと計算量](https://github.com/humiki-kirora/enginner_study/blob/main/%E8%AA%AD%E6%9B%B8/%E7%AB%B6%E6%8A%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E9%89%84%E5%89%87/%E7%AB%B6%E6%8A%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E9%89%84%E5%89%87.md#1%E7%AB%A0-%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E8%A8%88%E7%AE%97%E9%87%8F)
- [2章 累積和](https://github.com/humiki-kirora/enginner_study/blob/main/%E8%AA%AD%E6%9B%B8/%E7%AB%B6%E6%8A%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E9%89%84%E5%89%87/%E7%AB%B6%E6%8A%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E9%89%84%E5%89%87.md#2%E7%AB%A0-%E7%B4%AF%E7%A9%8D%E5%92%8C)
- [3章 二分探索]()
- [4章 動的計画法]()
- [5章 数学的問題]()
- [6章 考察テクニック]()
- [7章 ヒューリスティック]()
- [8章 データ構造とクエリ処理]()
- [9章 グラフアルゴリズム]()
- [10章 総合問題]()
- [終章 さらに上達するには]()


# 序章 競技プログラミング入門

## 競技プログラミングとは
プログラミングの問題を解くことを競技にしたもので「競プロ」と言われるもの  
約15年程度前に本格的に始まった競技だが、現在国内だけで3万人程度のアクティブユーザがおり、中高生からプログラマまで幅広い層が参加しており、コーディングスキル向上や教育などの目的で利用されることも多い

## コンテストの種類
- AtCoder (https://atcoder.jp/?lang=ja)  
日本最大手のプログラミングコンテスト  毎週末21時からオンラインで開催  
コンテストの成績に応じたレーティングがつけられるという特徴があり、強さの照明になるという点で、技術系のアルバイトや就職活動に利用されることもある  

- 日本情報オリンピック(JOI)  
高校生以下を対象とするコンテスト  
毎年1500人程度が参加して4人まで絞り、日本代表として世界大会に出場できる  
自分には関係のないことなので省略

- 大学対抗プログラミングコンテスト(ICPC)  
ICPC Foundationが開催する大学生向けのコンテスト  
3人チームでの参加のため、AtCoderと違って戦略とチームワークが重要  
自分には関係のないことなので省略  

- Google Code Jam  
Google社が毎年開催している競技プログラミングの大会  
世界各地から毎年2万人程度が予選に参加  
2時間半で3~4問解く形式で行われて、3回の予選を勝ち抜いた上位25人は現地で行われる決勝戦に参加できる

- アルゴリズム実技検定(PAST)(https://past.atcoder.jp/)  
日本初のアルゴリズム構築能力を測る検定試験  
AtCoder社が主催しており、検定料は8800円と金がかかるが、基準点に達した場合は「アルゴリズムができる人材」の証明になるため、市場価値のアップに繋がる

この中ではAtCoder、Google Code Jam、アルゴリズム実技検定(PAST)が自分には関係ありそう  

## 競技プログラミングで求められること
- プログラミング能力  
プログラミングを書く必要があるので、どれかの一つの言語について必要な機能を利用して希望通りの機能を素早くコーディングする能力が求められる

- アルゴリズムの知識  
競技プログラミングでは処理時間の制約があり、正しい答えを出すだけでは不十分な場合がある  
そのため、より効率的に答えを導き出すための典型的なアルゴリズムを学ぶ必要がある

- 思考力・発想力  
競技プログラミングで出題される問題はアルゴリズムの知識だけで解けるとは限らない  
問題を上手く分解したり、規則性に着目したりなどの発想力やひらめきが要求されることもある  
また複雑な問題を整理して解き切るために必要な論理的思考力も重要

## 本書の進め方
- 読み方
全部で10章で構成されており、1章で競技プログラミングで戦う上での基礎となるアルゴリズムや計算量について概観する。  
2~9章以降は頻出の典型アルゴリズムや考察テクニックについて触れている  
それぞれ独立しているため、どこから始めても大丈夫

- 例題・応用問題・力試し問題  
★1~6の難易度の問題が用意されており、難易度が高いほど知識や応用力が必要になる

- 自動採点システム (https://atcoder.jp/contests/tessoku-book)  
本書の例題・応用問題・力試し問題を正しいか機械的に判定する自動採点システムがあるため利用可能

# 1章 アルゴリズムと計算量  

## アルゴリズムとは
アルゴリズムとは問題を解くための**計算の手順**のこと  
同じ問題を解くとしても複数のアルゴリズムが考えられ、効率の良し悪しが異なる場合がある

### 具体例1 1+2+...+50を計算
一番ナイーブな方法としては1から順に足し算を行う方法でこれでも正解の1275を求める事ができる  
ただし、足し算を49回行う必要があり、計算するのが大変である  

そこで、以下のように考える
```
 1 + 2 + 3 + ... + 50 = (1 + 50) + (2 + 49) + (3 + 48) + ... + (25 + 26) = 51 * 25 
```
このように51が25個存在しているという風に考えることで、一回の掛け算の計算で答えを得ることができ、効率的に計算が可能  

### 具体例2 迷路の最短手数
以下の迷路の最短経路を求めることを考える  
![迷路](images/1_maize.png)

一番ナイーブな方法としてはスタート地点から出発する全ての経路について調べることで**全探索**と呼ばれている方法  
ただし、この規模の迷路ですら経路数は15万通り以上の経路を調べる必要があり、コンピュータの力を借りなければ到底実現できない  

そこでより良い解放を考える  
まず、スタート地点を「0」として書き込み、その隣接している経路に「1」と書き込む  
その後、同様に隣接していてまだ数字が書かれていない経路に2,3,...と順に書き込む操作を行うと最終的に以下のような結果が得られる  

![](images/1_maze_algorithm.png)

このようにすることで、ゴールまでの最短手数20が計算されるので、ゴールから順に20⇒19⇒18と辿っていくことで全探索よりも少ない探索で最短経路を得ることができる  
このアルゴリズムは**幅優先探索**と呼ばれている(第9章で扱う)  

このように同じ問題を解くにしても複数のアルゴリズムがあり、効率が大きく異なる  

## 計算量
アルゴリズムによって効率が変化するのは分かったが、アルゴリズムの効率をどのように評価するべきか  
どこで用いられるのが**計算量**という概念

計算量はアルゴリズムの効率を評価する1つの指標であり、*O*記法を用いて*O(N)*,*O(N^2)*,*O(2^N)*等の形で表され次のような意味を持つ

|  計算量  |  意味  |
| ---- | ---- |
|  O(N)  |  計算回数が概ねNに比例する  |
|  O(N^2)  |  計算回数が概ねN^2に比例する  |
|  O(2^N)  |  計算化数が概ね2^Nに比例する  |

### 計算量の例
先ほどの[具体例1]()で説明した1ずつ足していく方法はN - 1回の足し算が必要なので計算量は*O(N)*
それに対し、工夫した解法の方は1回の掛け算で済むため、*O(1)*となる

このように*O*記法では大まかな計算回数を表している

### 計算量の目安
各計算量における計算回数とNの関係を以下の表に示す  
家庭用PCの計算速度は毎秒10億回程度であるため、10^9を超える部分は赤色になっている  
競技プログラミングにおいては、赤色で塗られた部分については正解となる可能性は低い
![](images/1_O_table.png)

## 第1章のゴール
次に全5問の例題を通して、アルゴリズムと計算量に関する理解と競技プログラミングの問題形式に慣れることを目指す  

## 1.1 導入問題
### A01 Thre First Problem ★1
問題文:https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_a

特に何も難しいことはないのでそのまま解ける
```C++
#include <bits/stdc++.h>
using namespace std;
 
int main(){
  int N;
  cin >> N;
  cout << N * N << endl;
  return 0;
}
```


### B01 A+B Problem
問題文:https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_bz  

特に何も難しいことはないのでそのまま解ける
```C++
#include <bits/stdc++.h>
using namespace std;
 
int main(){
  int A,B;
  cin >> A >> B;
  cout << A + B << endl;
  return 0;
}
```

## 1.2 全探索(1) ★1
**全探索**は有り得る全てのパターンを調べ上げる方針で問題を解く方法  
Ex)4桁の暗証番号を0000~9999までのすべての番号を試す  
一番シンプルで確実に解けるが、時間的には効率が悪い
### A02 Linear Search
問題文:https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_b  

set<>を使うと重複を避けられる
```C++
#include <bits/stdc++.h>
using namespace std;
 
int main(){
  int N,X;
  cin >> N >> X;

  set<int> A;
  for(int i = 0; i < N; i ++) {
    int tmp;
    cin >> tmp;
    A.insert(tmp);
  }

  if(find(A.begin(),A.end(),X) != A.end()){
    cout << "Yes" << endl;
  }
  else {
    cout<< "No" << endl;
  }

  return 0;
}
```

## 1.3 全探索(2)
### A03 Two Cards ★1
問題文:https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_c  

P+Qのパターンを二重ループで全て試すと正解できる
```C++
#include <bits/stdc++.h>
using namespace std;
 
int main(){
    int N,K;

    cin >> N >> K;
    vector<int> P(N),Q(N);

    for(int i = 0; i < N; i ++) cin >> P[i];
    for(int i = 0; i < N; i ++) cin >> Q[i];

    for(int i = 0; i < N; i ++){
        for(int j = 0; j < N; j ++){
            if(K == P[i] + Q[j]){
                cout << "Yes" << endl;
                return 0;
            }
        }
    }

    cout << "No" << endl;
    return 0;
}
```

### B03 Supermarket 1
問題文:https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_cb

3重ループで全パターンを試す
```C++
#include <bits/stdc++.h>
using namespace std;
 
int main(){
    int N;
    cin >> N;

    vector<int> A(N);
    for(auto & a : A) cin >> a;

    for(int i = 0; i < N - 2; i ++){
        for(int j = i + 1; j < N - 1; j ++){
            for(int k = j + 1; k < N; k ++){
                if(A[i] + A[j] + A[k] == 1000){
                    cout << "Yes" << endl;
                    return 0;
                }
            }
        }
    }

    cout << "No" << endl;
    return 0;
}
```
## 1.4 2進法
### A04 Binary Representation 1 ★2
問題文:https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_d

普通に10進数を2進数に変更する方法を試す
```C++
#include <bits/stdc++.h>
using namespace std;
 
int main(){
    int N;
    cin >> N;

    vector<int> ans;
    int tmpN = N;
    while( (tmpN / 2) != 0){
        ans.push_back(tmpN % 2);
        tmpN = tmpN / 2;
    }
    ans.push_back(1);

    //0埋め
    for(int i = 0; i < 10 - ans.size(); i++) cout << 0;

    for(int i = ans.size() - 1; i >= 0; i --){
        cout << ans[i];
    }
    cout << endl;

    return 0;
}
```

**別解**  
対象の数字を2^n(n=0~9)までの数で割った余りを表示すれば簡単に解ける　　
```C++
#include <bits/stdc++.h>
using namespace std;
 
int main(){
    int N;
    cin >> N;

    for(int i = 9; i >= 0; i --){
        int num = (1 << i);
        cout << (N / num) % 2;
    }
    cout << endl;

    return 0;
}
```

### B04 Binary Representation 2
問題文:https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_cc

2⇒10進数変換では10で割った余りを用いて、位に応じてシフトしたものの合計を計算すればよい
```C++
#include <bits/stdc++.h>
using namespace std;
 
int main(){
    int N;
    cin >> N;

    int ans = 0;
    int count = 0;
    while(N > 0){
        ans += (( N % 10) << count);
        count ++;
        N /= 10;
    }

    cout << ans << endl;
    return 0;
}
```
### 1.5 チャレンジ問題 ★2
問題文:https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_e

2枚のカードが決まれば3枚目は自動的に決まるので2重ループの探索で求まる
```C++
#include <bits/stdc++.h>
using namespace std;
 
int main(){
    int N,K;
    cin >> N >> K;
    int ans = 0;

    for(int r = 1; r <= N; r ++){
        for(int b = 1; b <= N; b ++){
            if(K - (r + b) > N || K - (r + b) < 1) continue;
            ans ++;
        }
    }

    cout << ans << endl;
    return 0;
}
```

### ビット全探索
本格的な全探索問題として、以下の部分和問題を考える
> N枚のカードがあり、1からNまでの番号がつけられている。
> カードiには整数Aiが描かれており、カードの中からいくつか選び、書かれた整数の合計がSとなるような方法があるかを判定する

この問題では、N=20程度の小さい値であれば、全探索で解くことが可能だが、  
単純に実装すると、N重のfor文が必要になるため実装がめんどくさい  

2進数を用いることで、カードの選び方を0以上2^N - 1以下の整数値に対応させることが可能

![](images/1_bit%E5%85%A8%E6%8E%A2%E7%B4%A2.png)

これにより、部分和問題を解くプログラムを簡単に実装可能

```C++
#include <bits/stdc++.h>
using namespace std;
 
int main(){
    int N,K;
    cin >> N >> K;
    
    vector<int> A(N);
    for(auto & a : A) cin >> a;

    int pattern = (1 << N);

    //0~2^N - 1の全パターンを探索
    for(int i = 0; i < pattern; i ++){
      int ans = 0;

      //iを2進数に変換して、1の箇所を足す
      for(int j = 0; j < N; j ++){
        int div = (i / (1 << j));
         if(div % 2 == 1) ans += A[j];
      }

      //一致すれば終了
      if(A[j] == K){
        cout << "Yes" << endl;
        return 0;
      }
    }

    cout << "No" << endl;
    return 0;
}
```

# 2章 累積和
## 2.0 累積和とは
最初に、以下の計算問題を考える
> ある遊園地では、1月前半の来場者数が以下の表のようになった。
> 4-13、3-10、2-15までの総来場者数を計算してください
 
![](images/2_%E7%B4%AF%E7%A9%8D%E5%92%8C%E4%BE%8B%E9%A1%8C1.png)

単純に考えるならば、1/4~1/13までの来場者数の総和をそのまま計算するだけで良いが、
これは面倒な上、他の期間の計算でも同じような計算が必要になり効率が悪い

そこで以下の表のように1月1日からの累積来場者数を前もって計算する

![](images/2_%E7%B4%AF%E7%A9%8D%E5%92%8C%E4%BE%8B%E9%A1%8C2.png)

この表を前もって計算しておくことで、以下の一回の引き算で期間の総来場者数を求めることができる
- 1/4~13の総来場者数　= 1/13時点の累積来場者数 - 1/3時点の累積来場者数
- 1/3~10の総来場者数　= 1/10時点の累積来場者数 - 1/2時点の累積来場者数
- 1/2~15の総来場者数　= 1/15時点の累積来場者数 - 1/1時点の累積来場者数

このように配列の先頭からの累積値を記録した累積和を前もって計算しておくと効率的に範囲の合計を計算できるようになる

## 2.1 一次元の累積和(1)
### A06 How Many Guests? ★2
問題文:https://atcoder.jp/contests/tessoku-book/tasks/math_and_algorithm_ai

そのままAの累積和を計算してから、引き算を行う  
累積和の日にちを0日目から計算することで、if文を使わずにスムーズに計算可能
```C++
#include <bits/stdc++.h>
using namespace std;
 
int main(){
    int N,Q;
    cin >> N >> Q;

    vector<int> A(N);
    for(auto & a : A) cin >> a;

    vector<int> cumsum(N + 1,0);
    cumsum[0] = 0;
    for(int i = 1; i < N + 1; i ++){
        cumsum[i] = cumsum[i - 1] + A[i - 1];
    }

    vector<pair<int,int>> Question(Q);
    for(auto & q : Question) cin >> q.first >> q.second;

    for(int i = 0; i < Q; i ++){
        int l = Question[i].first;
        int r = Question[i].second;
        cout << cumsum[r] - cumsum[l - 1] << endl;
    }

    return 0;
}
```

### B06 Lottery
問題文:https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_ce

当たりの累積和を計算して、その区間の当たりの数を計算  
その後、その区間の日数と当たりの数を照らし合わせて判定すればよい
```C++
#include <bits/stdc++.h>
using namespace std;
 
int main(){
    int N,Q;
    cin >> N;

    vector<int> A(N);
    for(auto & a : A) cin >> a;

    vector<int> cumsum(N+1);
    cumsum[0] = 0;
    for(int i = 1; i < N + 1; i ++){
        cumsum[i] = cumsum[i - 1] + A[i - 1]; 
    }

    cin >> Q;
    vector<pair<int,int>> question(Q);
    for(auto & q : question) cin >> q.first >> q.second;

    for(auto & q : question){
        int l = q.first;
        int r = q.second;
        int hit = cumsum[r] - cumsum[l - 1];
        int no_hit = (r - l + 1) - hit;
        if(hit == no_hit) cout << "draw" << endl;
        else if(hit > no_hit) cout << "win" << endl;
        else cout << "lose" << endl;
    }


    return 0;
}
```

## 2.2 一次元の累積和
### A07 Event Attendance ★3
問題文:https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_g

普通にやると、各人の参加日程を調べて、その日程分プラスしていくという処理が必要になるが  
日程が多いとそれだけで処理時間がかなり増えてしまい時間切れになる  
例えば、D = 10^5日でN = 10^5人が全日参加した時、D * N　= 10^10回の加算処理が行われる  
<br>
そこで、前日比を考えて、**前日比の累積和**を取ることで効率的に解くことができる  
まず、参加者の最初の参加日をL日目、最終日をR日目として、
L日目に1人増えるので+1,R - 1日は1人減るので-1という風に記録していき、この処理を全ての参加者に対して行う事で前日比を算出できる
<br>  
前日比なので、0日目を0人として前日比の累積和を計算すると、各日の参加者の数を算出することができる

ここで先ほどのD=10^5 N=10^5の例との計算量を比較してみる  
前日比の累積和を使用したアルゴリズムでは以下の計算が行われる
- 1人に対して加算回数は2回だけなので、10^5 * 2
- 累積和を計算するのに、10^5回の加算処理

そのため、加算回数は```10^5 * 2 + 10^5 = 10^5 * 3 < 10^10```となり、より少ない計算回数で問題を解く事が可能となる

```C++
#include <bits/stdc++.h>
using namespace std;
 
int main(){
    int D,N;
    cin >> D >> N;

    vector<pair<int,int>> person(N);
    for(auto & p : person) cin >> p.first >> p.second;

    vector<int> ratio(D + 2,0),cumsum(D + 2,0);
    for(auto & p : person){
        int l = p.first;
        int r = p.second;
        ratio[l] ++;
        ratio[r + 1] --;
    }

    cumsum[0] = 0;
    for(int i = 1; i < D + 1; i ++){
        cumsum[i] = ratio[i] + cumsum[i - 1];
    }

    for(int i = 1; i < D + 1; i ++){
        cout << cumsum[i] << endl;
    }
    
    return 0;
}
```

### B07 Convenience Store 2
問題文:https://atcoder.jp/contests/tessoku-book/tasks/math_and_algorithm_al  

A07と基本的には同じように解く  
今回は前日比の代わりに、先に時刻Tにおける人数の増減を記録することで、
累積和で時刻T~T+1の間に出勤している人数を求める事ができる

```C++
#include <bits/stdc++.h>
using namespace std;
 
int main(){
    int T,N;
    cin >> T >> N;

    vector<pair<int,int>> person(N);
    for(auto &p : person) cin >> p.first >> p.second;

    vector<int> rate(T+2,0);

    for(int i = 0; i < person.size(); i ++){
        rate[person[i].first + 1] ++;
        rate[person[i].second + 1] --;
    }

    vector<int> cumsum(T+2,0);
    for(int i = 1; i < T + 2; i++){
        cumsum[i] = cumsum[i - 1] + rate[i];
    }

    for(int i = 1; i < T + 1; i ++){
        cout << cumsum[i] << endl;
    }

    return 0;
}
```

## 2.3 二次元の累積和
### A08 Two DImensional Sum ★4
問題文:https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_h  

累積和は1次元だけでなく、2次元にも適用することが可能  
二次元の累積を取る場合は、先に行方向の累積和を計算し、その計算結果を元に列方向の累積和を計算することで、
座標(1,1)から座標(a,b)の矩形の全ての要素の和を座標(a,b)に計算することができる  
この累積和を元に任意の座標(a,b)と座標(c,d)内の累積和がを求める場合は以下のように求める事が可能

```
座標(c,d)の累積和 - (座標(c,b -1)の累積和 + 座標(a - 1,d)の累積和 - 座標(a-1 , b-1)の累積和)
```

具体的には以下のようなイメージの計算が行われる  
重複する部分があるため、その分を引きすぎないように注意が必要<br>
![](images/2_%E4%BA%8C%E6%AC%A1%E5%85%83%E7%B4%AF%E7%A9%8D%E5%92%8C.png)

```C++
#include <bits/stdc++.h>
using namespace std;
 
int main(){
    int H,W;
    cin >> H >> W;
    vector<vector<int>> matrix(H,vector<int>(W,0));

    for(auto & row : matrix)
        for(auto & col : row) cin >> col;

    int Q;
    cin >> Q;
    vector<vector<int>> question(Q,vector<int>(4,0));

    for(auto & row : question)
        for(auto & col : row) cin >> col;
    
    vector<vector<int>> cumsum(H + 1,vector<int>(W + 1,0));
    for(int i = 1; i < H + 1 ; i ++){
        for(int j = 1; j < W + 1; j ++){
            cumsum[i][j] = cumsum[i][j - 1] + matrix[i - 1][j - 1];
        }
    }

    for(int i = 1; i < H + 1 ; i ++){
        for(int j = 1; j < W + 1; j ++){
            cumsum[i][j] = cumsum[i][j] + cumsum[i - 1][j];
        }
    }

    for(auto & q : question){
        cout << cumsum[q[2]][q[3]] - (cumsum[q[2]][q[1] - 1] + cumsum[q[0] - 1][q[3]] - cumsum[q[0] - 1][q[1] - 1]) << endl;
    }

    return 0;
}
```

# 3章 二分探索
# 4章 動的計画
# 5章 数学的問
# 6章 考察テクニック
# 7章 ヒューリスティック
# 8章 データ構造とクエリ処理
# 9章 グラフアルゴリズム
# 10章 総合問題
# 終章 さらに上達するには