開始日 2023/07/02  
読了日 2023/ * / *  
著者 Joel Grus 2020年4月28日初版

<!-- omit in toc -->
# 目次
- [1章 イントロダクション](#1章-イントロダクション)
- [2章 python速習](#2章-python速習)
- [3章 データの可視化](#3章-データの可視化)
- [4章 線形代数](#4章-線形代数)
  - [ベクトル](#ベクトル)
  - [行列](#行列)

# 1章 イントロダクション
- Webサイトは全てのユーザーのクリックを全て記録してるし、スマートフォンは毎秒ごとに位置情報と移動方向の記録を読み上げている<br>
- 定量化主義者(Quantified selfers)は心拍数、運動量、摂取カロリー、睡眠パターンを常に記録するウェアラブルデバイスを付けている<br>
- スマートカーは運転パターンを、スマートホームは生活習慣を、スマートマーケットは購買パターンを収集する<br>

これらのデータに埋もれているのはこれまで誰もが考えたこともないような無数の問いに対する答えです。本書ではこれらを見つける方法を学ぶための本です。

**データサイエンティスト**は定義が曖昧なことが多いので、**本書においては大量の乱雑なデータから物事の本質を引き出す者**と定義します。<br>
例えば、
- 出会い系サイトOkCupid
  - 大量の質問をメンバーに行い、最も適した相手を見つける。同時に最初のデートで相手を退屈させないように、相手が興味を持たない分野を明らかにする分析を行う
- Facebook
  - これまで住んでいた場所と現在の居住地を尋ね、メンバーの友達を発見しやすくする。同時に移住パターンごとにフットボールチームの好みを分析したりもできる
- 大規模小売店Target
  - 実店舗とオンラインでの購買履歴及び挙動を記録し、顧客に子供が生まれる予定の有無や、いつ新生児関連の商品を売り込むべきであるかを予測するモデルの為にデータを使う
- その他
  - オバマの選挙運動での選挙手法の試み
  - データの活用による政府の効率化、ホームレスの救済、公衆衛生の向上

このようなデータを分析することで、物事の関係を見出し、効率的に行動を選択できるようする事ができるものを**データサイエンティスト**とする

そんなデータサイエンティストになるために統計的知識を本書を通して学びます

# 2章 python速習
内容があらかた既知なので割愛。[こちらを参照](../../Language/python/python%E9%80%9F%E7%BF%92/%E5%9F%BA%E6%9C%AC%E6%A7%8B%E6%96%87.md)

# 3章 データの可視化
matplotlibの説明は別途用意したため割愛。[こちらを参照](../../Language/python/python%E9%80%9F%E7%BF%92/matplotlib.md)

# 4章 線形代数
線形代数は**ベクトル空間**を扱うための数学の分野
データサイエンスにおいてはあらゆる場面において線形代数が使われており、非常に重要であるためきちんと理解しておく必要がある

## ベクトル
**ベクトル**とはいくつかの数値をまとめたオブジェクトであり、ベクトル同士の加算などで新しいベクトルを作成することができる。
例えば、身体のデータは、**[身長, 体重, 年齢]** の3次元のベクトルとして扱う事もできる。他にも座標などを **[x, y]** の2次元のベクトルとして扱うことも多い

ベクトルを扱うには加減積商の他に以下のいくつか必要な計算機能が必要である
- **内積(dot積)**
  - 二つのベクトルの同じ位置の要素同士を掛け合わせて、その総和をとったもの
  - $ \bold{a} = [a_1,a_2,...,a_n] ,\bold{b}=[b_1,b_2,...,b_n]$の時、
  $\bold{a ・ b}=a_1b_1 + a_2b_2 + ... + a_nb_n $
  - 内積は$\bold{a ・ b}=||a||||b||\cosθ$の式で表す事もでき、二つのベクトルのなす角を求めるのに使える
- **外積(cross積)**
  - 二つの3次元ベクトルから以下の計算方法で表されるベクトルの事
  - $ \bold{a} = [a_1,a_2,a_3] ,\bold{b}=[b_1,b_2,b_3]$の時、
  $\bold{a \times b}= \begin{bmatrix}
   a_2b_3 - a_3b_2 \\ a_3b_1 - a_1b_3 \\ a_2b_3 - a_3b_2
  \end{bmatrix} $
  - いわゆる二つのベクトルに直交するベクトルを求める事ができる
- **マグニチュード(ベクトルの大きさ)**
  - ベクトルの大きさの表現方法はいくつかある
    - $\bold{a} = [a_1,a_2,...,a_n]$の時
    - L1ノルム:$||a||_1=|a_1| + |a_2| + ... + |a_n|$
      - 全ての要素の絶対値を取って足し合わせたモノ。**マンハッタン距離**ともいう
    - L2ノルム:$||a||_2=\sqrt{a_1^2 + a_2^2 + ... + a_n^2}$
      - 全ての要素の二乗和をとって足し合わせて、平方根をとったもの。**ユークリッド距離**という
      - 一番よく使われているもの
    - ベクトル最大値ノルム:$||a||_{inf}=max(|\bold{a}|)$
      - ベクトルの要素から最大値を取り出したもの

以下、リストを使った各算術の実装を書くが、実際には**numpy**ライブラリを使った方が簡単に実装ができる。(この後はnumpyを使っていく)
```python

from math import *

def add(a,b):
    assert len(a) == len(b)
    return [x + y for x,y in zip(a,b)]

def subtract(a,b):
    assert len(a) == len(b)
    return [x - y for x,y in zip(a,b)]

def product(a,b):
    assert len(a) == len(b)
    return [x * y for x,y in zip(a,b)]

def div(a,b):
    assert len(a) == len(b)
    return [x / y for x,y in zip(a,b)]

def dot(a,b):
    assert len(a) == len(b)
    num = 0
    for x,y in zip(a,b):
        num += x * y
    return num

def cross(a,b):
    assert len(a) == len(b)
    assert len(a) == 3
    return [a[1] * b[2] - a[2] * b[1],a[2] * b[0] - a[0] * b[2],a[0] * b[1] - a[1] * b[0]]

def L1norm(a):
    num = 0
    for x in a:
        num += abs(x)
    return num

def L2norm(a):
    return sqrt(dot(a,a))

def Linfnorm(a):
    return max(a)

a =[1,2,3]
b = [4,5,6]

print(add(a,b))
print(subtract(a,b))
print(product(a,b))
print(div(a,b))

print(dot(a,b))
print(cross(a,b))

print(L1norm(a))
print(L2norm(a))
print(Linfnorm(a))
```

## 行列
行列は数値はn×mの二次元に配置したもので,